# try:
#     x, y = map(int, input().split())
#     res = x / y
# except ZeroDivisionError as z:
#     print(z)
# except ValueError as z:
#     print(z)
# else:
#     print("Исключений не произошло")

# Теперь, при запуске программы, вводя корректные числа, мы увидим сообщение «Исключений не произошло».
# Если же возникает какое-либо исключение, то этот блок выполняться не будет.
# Вторым необязательным блоком является блок finally, который, наоборот, выполняется всегда после блока try, вне зависимости произошла ошибка или нет:
#
# finally:
#     print("Блок finally выполняется всегда")


# def get_values():
#     try:
#         x, y = map(int, input().split())
#         return x, y
#     except ValueError as v:
#         print(v)
#         return 0, 0
#     finally:
#         print("finally выполняется до return")
#
# x, y = get_values()
# print(x, y)


# try:
#     x, y = map(int, input().split())
#     try:
#         res = x / y
#     except ZeroDivisionError:
#         print("Деление на ноль")
# except ValueError as z:
#     print("Ошибка ValueError")
#
# Или, можно внутренний блок try вынести в функцию:
#
# def div(a, b):
#     try:
#         return x / y
#     except ZeroDivisionError:
#         return "Деление на ноль"


# А, затем, вызвать в первом блоке try:
#
# try:
#     x, y = map(int, input().split())
#     res = div(x, y)
# except ValueError as z:
#     print("Ошибка ValueError")
# print(res)




# =======================


# Подвиг 1. Имеется следующий фрагмент программы:
#
# try:
#     val = float(input())
# except ValueError as e:
#     print(e)
# else:
#     val *= 10
#     print(val)
#
# При каких входных данных выполнение программы перейдет в блок else?
#
#
#
# (YES) - при вводе любых вещественных значений
# всегда будет переходить, вне зависимости от возникновения исключений
# (YES) - при вводе любых целочисленных значений
# при вводе любых не числовых значений



# =====================================





# Подвиг 2. В каком порядке можно записывать блоки try/except/else/finally, чтобы программа работала без ошибок?
#
# (YES) - try/ except / finally
# try/ finally / except / else
# (YES) - try/ except / else
# try/ except / finally / else
# (YES) - try/ except / else / finally


# ======================================





# Подвиг 3. Имеется следующий фрагмент программы:
#
# try:
#     val = float(input())
# except ValueError as e:
#     print(e)
# else:
#     val *= 10
#     print(val)
# finally:
#     print("finally")
#
# При каких входных данных выполнение программы перейдет в блок finally?


# (YES) - при вводе любых целочисленных значений
# (YES) - при вводе любых строк (данных)
# (YES) - всегда будет переходить, вне зависимости от возникновения исключений
# (YES) - при вводе любых вещественных значений
# (YES) - программа не будет выполнена, так как блок finally должен быть записан перед блоком else


# =====================================================================




# Подвиг 4. В программе вводятся два значения в одну строчку через пробел. Значениями могут быть числа, слова,
# булевы величины (True/False). Необходимо прочитать эти значения из входного потока. Если оба значения являются числами,
# то вычислить их сумму, иначе соединить их в одну строку с помощью оператора + (конкатенации строк). Результат вывести на экран (в блоке finally).
# P.S. Реализовать программу с использованием блоков try/except/finally.
# Sample Input:
# 8 11
# Sample Output:
# 19
# a, b = input().split()
# a = '1.0'
# b = '3.0'
# try:
#     a, b = int(a), int(b)
# except ValueError:
#     try:
#         a, b = float(a), float(b)
#     except ValueError:
#         pass
# finally:
#     print(a + b)




# ======================================================================================


# Подвиг 5. Объявите в программе класс Point, объекты которого должны создаваться командами:
# pt = Point()
# pt = Point(x, y)
# где x, y - произвольные числа (координаты точки).
# В каждом объекте класса Point должны формироваться локальные атрибуты _x, _y с соответствующими значениями.
# Если аргументы не указываются (первая команда), то _x = 0, _y = 0.
# Далее, в программе вводятся два значения в одну строчку через пробел.
# Значениями могут быть числа, слова, булевы величины (True/False). Необходимо прочитать эти значения из входного потока.
# Если оба значения являются числами, то формировать объект pt командой:
# pt = Point(x, y)
# Если хотя бы одно из значений не числовое, то формировать объект pt командой:
# pt = Point()
# Реализовать этот функционал с помощью блоков try/except. А в блоке finally вывести на экран сообщение в формате (без кавычек):
# "Point: x = <значение x>, y = <значение y>"
# Sample Input:
# 10 20
# Sample Output:
# Point: x = 10, y = 20

# class Point:
#     def __init__(self, x=0, y=0):
#         if type(x) not in (int, float) or type(y) not in (int, float):
#             raise ValueError('Boooooooo')
#         self._x = x
#         self._y = y
#
# try:
#     pt = Point(*list(map(int, input().split())))
# except ValueError:
#     pt = Point()
# finally:
#     print(f"Point: x = {pt._x}, y = {pt._y}")



# =======================================================================================================




# Подвиг 6. В программе объявлена функция для вычисления частного двух чисел:
# def get_div(x, y):
#     try:
#         res = x / y
#         return res
#     except ZeroDivisionError:
#         res = 100
#         return res
#     finally:
#         res = -1
#         print(f"finally: {res}")

# Выберите все верные утверждения, связанные с этой программой.
# Выберите все подходящие ответы из списка
# Верно решили 923 учащихся
# Из всех попыток 47% верных
#(YES) - при вызове get_div(10, 0) функция возвратит значение 100 и на экран будет выведена строчка "finally: -1"
#(YES) -  при вызове get_div(1, 2) функция возвратит значение 0.5 и на экран будет выведена строчка "finally: -1"
# при вызове get_div(10, 0) функция возвратит значение -1 (так как блок finally выполняется до оператора return) и на экран будет выведена строчка "finally: -1"
# при вызове get_div(1, 2) функция возвратит значение -1 (так как блок finally выполняется до оператора return) и на экран будет выведена строчка "finally: -1"

# s = [(10,0), (1,2)]
# for i in s:
#     print(get_div(*i))


# ========================================================================================================


# Подвиг 7. В практике программирования блок else используют как элемент отладки программы: в него прописывают текст программы,
# в котором заведомо не произойдет исключений, отлавливаемых в блоке try. Выполним на практике такой пример.
# Вам необходимо объявить функцию с сигнатурой:
# def get_loss(w1, w2, w3, w4): ...
# где w1, w2, w3, w4 - любые числа. Функция должна возвращать значение, вычисленное по формуле:
# y = 10 * w1 // w2 - 5 * w2 * w3 + w4
# Здесь фрагмент вычисления w1 // w2 содержит потенциальную ошибку деления на ноль, поэтому его следует делать в блоке try.
# А в блоке else продолжить вычисления, где не используются операции деления.
# Если происходит деление на ноль, то функция должна возвращать строку:
# "деление на ноль"
# P.S. В программе нужно объявить только функцию. Вызывать ее и выводить на экран ничего не нужно.
#
#
# def get_loss(w1, w2, w3, w4):
#     try:
#         y = 10 * w1 // w2 - 5 * w2 * w3 + w4
#     except ZeroDivisionError:
#         return "деление на ноль"
#     else:
#         return 10 * w1 - 5 * w2 * w3 + w4



# ===============================================================================================================



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/o66Is1ab4ho
# Подвиг 8. Объявите класс с именем Rect (прямоугольник), объекты которого создаются командой:
# r = Rect(x, y, width, height)
# где x, y - координаты верхнего левого угла (любые числа); width, height - ширина и высота прямоугольника (положительные числа).
# Ось абсцисс (Ox) направлена вправо, ось ординат (Oy) направлена вниз.
# В каждом объекте класса Rect должны формироваться локальные атрибуты с именами: _x, _y, _width, _height и соответствующими значениями.
# Если переданные аргументы x, y (не числа) и width, height не положительные числа, то генерировать исключение командой:
# raise ValueError('некорректные координаты и параметры прямоугольника')
# В классе Rect реализовать метод:
# def is_collision(self, rect): ...
# который проверяет пересечение текущего прямоугольника с другим (с объектом rect). Если прямоугольники пересекаются,
# то должно генерироваться исключение командой:
# raise TypeError('прямоугольники пересекаются')
# Сформировать в программе несколько объектов класса Rect со следующими значениями:
# 0; 0; 5; 3
# 6; 0; 3; 5
# 3; 2; 4; 4
# 0; 8; 8; 1
# Сохранить их в списке lst_rect. На основе списка lst_rect сформировать еще один список lst_not_collision,
# в котором должны быть объекты rect не пересекающиеся ни с какими другими объектами в списке lst_rect.
# P.S. В программе требуется объявить только класс и списки. На экран выводить ничего не нужно.
# Подсказка. Для определения пересечения двух прямоугольников, у которых стороны параллельны осям координат (как в этом подвиге)
# достаточно проверить, что верхняя грань первого прямоугольника находится ниже нижней грани второго, или нижняя грань
# первого прямоугольника выше верхней грани второго. И то же самое для вертикальных граней.


class Rect:
    def __init__(self, x, y, width, height):
        self._x = x
        self._y = y
        self._width = width
        self._height = height

    def __setattr__(self, key, value):
        if type(value) not in (int, float):
            raise ValueError('некорректные координаты и параметры прямоугольника')
        if key in ('_width', '_height') and value <= 0:
            raise ValueError('некорректные координаты и параметры прямоугольника')

        object.__setattr__(self, key, value)

    def is_collision(self, rect):
        if not isinstance(rect, Rect):
            raise TypeError('bad type')
        if not (self._x + self._width < rect._x or rect._x + rect._width < self._x or self._y + self._height < rect._y or rect._y + rect._height < self._y):
            raise TypeError('прямоугольники пересекаются')




lst_rect = [Rect(0, 0, 5, 3), Rect(6, 0, 3, 5), Rect(3, 2, 4, 4), Rect(0, 8, 8, 1)]
def is_collision(r1, r2):
    try:
        r1.is_collision(r2)
    except TypeError:
        return True
    return False


lst_not_collision = [lst_rect[i] for i in range(len(lst_rect))
                     if not any(is_collision(lst_rect[i], lst_rect[j]) for j in range(len(lst_rect)) if i != j)]
print(lst_not_collision)


# r = Rect(1, 2, 10, 20)
# assert r._x == 1 and r._y == 2 and r._width == 10 and r._height == 20, "неверные значения атрибутов объекта класса Rect"

# r2 = Rect(1.0, 2, 10.5, 20)
#
# try:
#     r2 = Rect(0, 2, 0, 20)
# except ValueError:
#     assert True
# else:
#     assert False, "не сгенерировалось исключение ValueError при создании объекта Rect(0, 2, 0, 20)"


# assert len(lst_rect) == 4, "список lst_rect содержит не 4 элемента"
# assert len(lst_not_collision) == 1, "неверное число элементов в списке lst_not_collision"
#
# def not_collision(rect):
#     for x in lst_rect:
#         try:
#             if x != rect:
#                 rect.is_collision(x)
#         except TypeError:
#             return False
#     return True
#
# f = list(filter(not_collision, lst_rect))
# assert lst_not_collision == f, "неверно выделены не пересекающиеся прямоугольники, возможно, некорректно работает метод is_collision"
#
# r = Rect(3, 2, 2, 5)
# rr = Rect(1, 4, 6, 2)
#
# try:
#     r.is_collision(rr)
# except TypeError:
#     assert True
# else:
#     assert False, "не сгенерировалось исключение TypeError при вызове метода is_collision() для прямоугольников Rect(3, 2, 2, 5) и Rect(1, 4, 6, 2)"
