# # коллекция __slots__
#
# class Point:
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y
#
#     def calc(self): #для вычисления времени работы
#         self.x += 1
#         del self.y
#         self.y = 0
#
# pt = Point(1, 2)
# pt.y = 10
# pt.z = 5
# # print(pt.__dict__)  #{'x': 1, 'y': 10, 'z': 5}   # создалось третье локальное свойство в экземпляре класса
#
# class Point2D:
#     __slots__ = ('x', 'y')  #такие локальные свойства будут разрешены
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y
#
# pt2 = Point2D(10, 20)
# # pt2.z = 30  #AttributeError: 'Point2D' object has no attribute 'z'
# # print(pt2.__dict__) #'Point2D' object has no attribute '__dict__'   коллекция отсутствует!!!
# # аттрибуты класса будут работать
# class Point2D1:
#     __slots__ = ('x', 'y')  #такие локальные свойства будут разрешены
#     MAX_COORD = 100
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y
#
#     def calc(self): #для вычисления времени работы
#         self.x += 1
#         del self.y
#         self.y = 0
#
# pt3 = Point2D1(10, 30)
# del pt3.y
# pt3.y = 50
# # print(pt3.MAX_COORD)
#
#
# # измеряем сколько памяти занимает:
# print(pt.__dict__.__sizeof__() + pt.__sizeof__()) # сам обьект и словарь - 120 bytes
#
# print(pt3.__sizeof__()) #dict не содержит и slots ускоряет работу+ весит меньше - 32 байта
#
# from timeit import timeit
# p = Point(1,2)
# p2 = Point2D1(3,4)
#
# t1 = timeit(p.calc)
# t2 = timeit(p2.calc)
# print(t1, t2, sep='   t1 < ------///////------> t2  ')  #0.3054594610002823   t1 < ------///////------> t2  0.23437615699367598

# ======================================================

# Как работает __slots__ с property и при наследовании

# class Point2D:
#     __slots__ = ('x', 'y', 'length')
#
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y
#         self.length = (x ** 2 + y ** 2) ** 0.5
#
# pt = Point2D(1, 2)
# print(pt.length) # 2.23606797749979
# допишем property

# class Point2D:
#     __slots__ = ('x', 'y', '__length')
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y
#         self.__length = (x ** 2 + y ** 2) ** 0.5
#
#     @property
#     def length(self):
#         return self.__length
#
#     @length.setter
#     def length(self, value):
#         self.__length = value
#
# pt = Point2D(1, 2)
# print(pt.length) # 2.23606797749979
# pt.length = 10
# print(pt.length)




# class Point2D:
#     __slots__ = ('x', 'y')
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y
#
# class Point3D(Point2D): pass
#
# # pt3 = Point3D(1, 2)
# # pt3.z = 10 # no error
# # print(pt3.__dict__) #{'z': 10} добавлено свойство z
#
# class Point3D(Point2D):
#     __slots__ = () #таким образом будут разрешены только от родительского класса
#
# # pt4 = Point3D(3,4)
# # pt4.z = 10  #AttributeError: 'Point3D' object has no attribute 'z'
# # print(pt4.__dict__) #AttributeError: 'Point3D' object has no attribute '__dict__'. Did you mean: '__dir__'?
#
#
# # если нужно дополнить класс:
#
# class Point3D(Point2D):
#     __slots__ = 'z', # нужна запятая, кортеж же!
#
# pt5 = Point3D(3,4)
# pt5.z = 10



# =========================================================================================




# Подвиг 1. На что влияет коллекция __slots__, объявленная внутри класса?
#
# (YES) - разрешает в экземплярах класса только те имена атрибутов, которые указаны в __slots__
# (NO) - разрешает в классе только те имена атрибутов, которые указаны в __slots__
# (YES) - в объектах класса пропадает коллекция __dict__
# (YES) - уменьшается объем памяти, занимаемый объектом класса
# (YES) - скорость обращения к локальным атрибутам повышается
# (NO) - скорость обращения к локальным атрибутам уменьшается



# ==========================================================================================

# Подвиг 2. В программе объявлены два класса следующим образом:
# class Money:
#     __slots__ = '_money',
#     def __init__(self, value):
#         self._money = value
# class MoneyR(Money):
#     pass
# И, затем, создается объект класса MoneyR:
# m = MoneyR(10)
# m.s = 100
# Выберите все верные утверждения, связанные с этой программой.

# (YES) - коллекция __slots__ накладывает ограничения на атрибуты объектов базового класса Money, но не дочернего класса MoneyR
# (NO) - программа завершится с ошибкой, т.к. коллекция __slots__ будет унаследована дочерним классом и локальный атрибут s не может быть создан
# (YES) - программа выполнится без ошибок, т.к. коллекция __slots__ отсутствует в классе MoneyR,
# то в его объектах можно создавать любые локальные атрибуты

# ===========================================================================================================

# Подвиг 3. В программе объявлены два класса следующим образом:
# class Money:
#     __slots__ = '_money',
#     def __init__(self, value):
#         self._money = value
# class MoneyR(Money):
#     __slots__ = '_value',
# И, затем, выполняются команды:
# m = MoneyR(10)
# m._money = 100
# m._value = 20
# Выберите все верные утверждения, связанные с этой программой.

# (NO) - программа завершится с ошибкой, так как коллекция __slots__ базового класса имеет приоритет и __slots__ дочернего класса будет проигнорирована
# (YES) - программа выполнится без ошибок, так как коллекция __slots__ дочернего класса расширяет коллекцию __slots__ базового класса и атрибуты с именами _money и _value допустимы
# (NO) - программа завершится с ошибкой, так как коллекция __slots__ не наследуется и в объекте m дочернего класса MoneyR допустим только атрибут _value
# (YES) - если в классе MoneyR прописать __slots__ = '_value', '_money', а в базовом классе убрать определение __slots__, то поведение объекта m дочернего класса MoneyR не изменится


# =============================================================================================================




# Подвиг 4. Объявите класс Person, в объектах которого разрешены только локальные атрибуты с именами (ограничение задается через коллекцию __slots__):
# _fio - ФИО сотрудника (строка);
# _old - возраст сотрудника (целое положительное число);
# _job - занимаемая должность (строка).
# Сами объекты должны создаваться командой:
# p = Person(fio, old, job)
# Создайте несколько следующих объектов этого класса с информацией:
# Суворов, 52, полководец
# Рахманинов, 50, пианист, композитор
# Балакирев, 34, программист и преподаватель
# Пушкин, 32, поэт и писатель
# Сохраните все эти объекты в виде списка с именем persons.
# P.S. В программе следует объявить только класс и создать список. На экран выводить ничего не нужно.

# class Person:
#     __slots__ = ('_fio', '_old', '_job')
#     def __init__(self, fio, old, job):
#         self._fio = fio
#         self._old = old
#         self._job = job
#
#
# persons = [Person('Суворов', 52, 'полководец'),
#            Person('Рахманинов', 50, 'пианист, композитор'),
#            Person('Балакирев', 34, 'программист и преподаватель'),
#            Person('Пушкин', 32, 'поэт и писатель')
#            ]



# ========================================================================================================================


# Подвиг 5. Объявите класс Planet (планета), объекты которого создаются командой:
# p = Planet(name, diametr, period_solar, period)
# где name - наименование планеты; diametr - диаметр планеты (любое положительное число); period_solar - период (время)
# обращения планеты вокруг Солнца (любое положительное число); period - период обращения планеты вокруг своей оси (любое положительное число).
# В каждом объекте класса Planet должны формироваться локальные атрибуты с именами: _name, _diametr, _period_solar, _period и
# соответствующими значениями.
# Затем, объявите класс с именем SolarSystem (солнечная система). В объектах этого класса должны быть допустимы,
# следующие локальные атрибуты (ограничение задается через коллекцию __slots__):
# _mercury - ссылка на планету Меркурий (объект класса Planet);
# _venus - ссылка на планету Венера (объект класса Planet);
# _earth - ссылка на планету Земля (объект класса Planet);
# _mars - ссылка на планету Марс (объект класса Planet);
# _jupiter - ссылка на планету Юпитер (объект класса Planet);
# _saturn - ссылка на планету Сатурн (объект класса Planet);
# _uranus - ссылка на планету Уран (объект класса Planet);
# _neptune - ссылка на планету Нептун (объект класса Planet).
# Объект класса SolarSystem должен создаваться командой:
# s_system = SolarSystem()
# и быть только один (одновременно в программе два и более объектов класса SolarSystem недопустимо).
# Используйте для этого паттерн Singleton.
# В момент создания объекта SolarSystem должны автоматически создаваться перечисленные локальные атрибуты и ссылаться
# на соответствующие объекты класса Planet со следующими данными по планетам:
# https://ucarecdn.com/cc1396d4-d9af-4518-bed5-2c45da00fdee/
# Создайте в программе объект s_system класса SolarSystem.
# P.S. В программе следует объявить только классы и создать объект s_system. На экран выводить ничего не нужно.

# class Planet:
#     def __init__(self, name, diametr, period_solar, period):
#         self._name = name
#         self._diametr = diametr
#         self._period_solar = period_solar
#         self._period = period
#
#
# class SolarSystem:
#     __instance = None
#     __slots__ = ('_mercury', '_venus', '_earth', '_mars', '_jupiter', '_saturn', '_uranus', '_neptune')
#     def __new__(cls):  #singleton
#         if not cls.__instance:
#             cls.__instance = super().__new__(cls)
#         return cls.__instance
#
#     def __init__(self):
#         self._mercury = Planet('Меркурий', 4878, 87.97, 1407.5)
#         self._venus = Planet('Венера', 12104, 224.7, 5832.45)
#         self._earth = Planet('Земля', 12756, 365.3, 23.93)
#         self._mars = Planet('Марс', 6794, 687, 24.62)
#         self._jupiter = Planet('Юпитер', 142800, 4330, 9.9)
#         self._saturn = Planet('Сатурн', 120660, 10753, 10.63)
#         self._uranus = Planet('Уран', 51118, 30665, 17.2)
#         self._neptune = Planet('Нептун', 49528, 60150, 16.1)
#
# s_system = SolarSystem()
# print(s_system)



# ===============================================================================================




# Подвиг 6. Объявите класс с именем Star (звезда), в объектах которого разрешены только локальные атрибуты с именами
# (ограничение задается через коллекцию __slots__):
# _name - название звезды (строка);
# _massa - масса звезды (любое положительное число); часто измеряется в массах Солнца;
# _temp - температура поверхности звезды в Кельвинах (любое положительное число).
# Объекты этого класса должны создаваться командой:
# star = Star(name, massa, temp)
# На основе класса Star объявите следующие дочерние классы:
# WhiteDwarf - белый карлик;
# YellowDwarf - желтый карлик;
# RedGiant - красный гигант;
# Pulsar - пульсар.
# В каждом объекте этих классов должны быть разрешены (дополнительно к атрибутам базового класса Star) только следующие локальные атрибуты:
# _type_star - название типа звезды (строка);
# _radius - радиус звезды (любое положительное число); часто измеряется в радиусах Солнца.
# Соответственно, объекты этих классов должны создаваться командой:
# star = Имя_дочернего_класса(name, massa, temp, type_star, radius)
# Создайте в программе следующие объекты звезд:
# RedGiant: Альдебаран; 5; 3600; красный гигант; 45
# WhiteDwarf: Сириус А; 2,1; 9250; белый карлик; 2
# WhiteDwarf: Сириус B; 1; 8200; белый карлик; 0,01
# YellowDwarf: Солнце; 1; 6000; желтый карлик; 1
# Все эти объекты сохраните в виде списка stars. Затем, с помощью функций isinstance() и filter() сформируйте новый список
# с именем white_dwarfs, состоящий только из белых карликов (WhiteDwarf).
# P.S. В программе следует объявить только классы и создать списки. На экран выводить ничего не нужно.

# class Star:
#     __slots__ = ('_name', '_massa', '_temp')
#
#     def __init__(self, name, massa, temp):
#         self._name = name
#         self._massa = massa
#         self._temp = temp
#
# class WhiteDwarf(Star):
#     __slots__ = '_type_star', '_radius'
#     def __init__(self, name, massa, temp, type_star, radius):
#         super().__init__(name, massa, temp)
#         self._type_star = type_star
#         self._radius = radius
#
# class YellowDwarf(Star):
#     __slots__ = '_type_star', '_radius'
#     def __init__(self, name, massa, temp, type_star, radius):
#         super().__init__(name, massa, temp)
#         self._type_star = type_star
#         self._radius = radius
#
# class RedGiant(Star):
#     __slots__ = '_type_star', '_radius'
#
#     def __init__(self, name, massa, temp, type_star, radius):
#         super().__init__(name, massa, temp)
#         self._type_star = type_star
#         self._radius = radius
#
# class Pulsar(Star):
#     __slots__ = '_type_star', '_radius'
#
#     def __init__(self, name, massa, temp, type_star, radius):
#         super().__init__(name, massa, temp)
#         self._type_star = type_star
#         self._radius = radius
#
# stars = [RedGiant('Альдебаран', 5, 3600, 'красный гигант', 45),
#          WhiteDwarf('Сириус А', 2.1, 9250, 'белый карлик', 2),
#          WhiteDwarf('Сириус B', 1, 8200, 'белый карлик', 0.01),
#          YellowDwarf('Солнце', 1, 6000, 'желтый карлик', 1)]
# #
# #
# white_dwarfs = list(filter(lambda x: isinstance(x, WhiteDwarf), stars))
# print(white_dwarfs)



# ====================================================================================================




# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/rtma49Ye7hY
# Подвиг 7. Объявите класс Note (нота), объекты которого создаются командой:
# note = Note(name, ton)
# где name - название ноты (допустимые значения: до, ре, ми, фа, соль, ля, си); ton - тональность ноты (целое число).
# Тональность (ton) принимает следующие целые значения:
# -1 - бемоль (flat);
# 0 - обычная нота (normal);
# 1 - диез (sharp).
# Если в названии (name) или тональности (ton) передаются недопустимые значения, то генерируется исключение командой:
# raise ValueError('недопустимое значение аргумента')
# В каждом объекте класса Note должны формироваться локальные атрибуты с именами _name и _ton с соответствующими значениями.
# Объявите класс с именем Notes, в объектах которого разрешены только локальные атрибуты с именами (ограничение задается через коллекцию __slots__):
# _do - ссылка на ноту до (объект класса Note);
# _re - ссылка на ноту ре (объект класса Note);
# _mi - ссылка на ноту ми (объект класса Note);
# _fa - ссылка на ноту фа (объект класса Note);
# _solt - ссылка на ноту соль (объект класса Note);
# _la - ссылка на ноту ля (объект класса Note);
# _si - ссылка на ноту си (объект класса Note).
# Объект класса Notes должен создаваться командой:
# notes = Notes()
# и быть только один (одновременно в программе два и более объектов класса Notes недопустимо). Используйте для этого паттерн Singleton.
# В момент создания объекта Notes должны автоматически создаваться перечисленные локальные атрибуты и ссылаться на
# соответствующие объекты класса Note (тональность (ton) у всех нот изначально равна 0).
# Обеспечить возможность обращения к нотам по индексам: 0 - до; 1 - ре; ... ; 6 - си. Например:
# nota = notes[2]  # ссылка на ноту ми
# notes[3]._ton = -1 # изменение тональности ноты фа
# Если указывается недопустимый индекс (не целое число, или число, выходящее за интервал [0; 6]), то генерируется исключение командой:
# raise IndexError('недопустимый индекс')
# Создайте в программе объект notes класса Notes.
# P.S. В программе следует объявить только классы и создать объект notes. На экран выводить ничего не нужно.

#
# class Note:
#     def __init__(self, name, ton):
#         self.__name = self._check_name(name)
#         self.__ton = self._check_ton(ton)
#
#     def _check_ton(self, value):
#         if not isinstance(value, int) or value not in (-1, 0, 1):
#             raise ValueError('недопустимое значение аргумента')
#         return value
#
#     def _check_name(self, value):
#         if value not in ('до', 'ре', 'ми', 'фа', 'соль', 'ля', 'си'):
#             raise ValueError('недопустимое значение аргумента')
#         return value
#
#     @property
#     def _ton(self):
#         return self.__ton
#
#     @_ton.setter
#     def _ton(self, value):
#         self.__ton = self._check_ton(value)
#

    # @property
    # def _name(self):
    #     return self.__name
    #
    # @_name.setter
    # def _name(self, value):
    #     self.__name = self._check_name(value)

# class Notes:
#     __instance = None
#     __slots__ = ('_do', '_re', '_mi', '_fa', '_solt', '_la', '_si')
#
#     def __new__(cls):
#         if not cls.__instance:
#             cls.__instance = super().__new__(cls)
#         return cls.__instance
#
#     def __init__(self):
#         self._do = Note('до', 0)
#         self._re = Note('ре', 0)
#         self._mi = Note('ми', 0)
#         self._fa = Note('фа', 0)
#         self._solt = Note('соль', 0)
#         self._la = Note('ля', 0)
#         self._si = Note('си', 0)
#
#     def __getitem__(self, item):
#         if item < 0 or item > 6:
#             raise IndexError('недопустимый индекс')
#         return getattr(self, self.__slots__[item])
#
#
# notes = Notes()
# print(notes[0]._ton)
# notes[0]._ton = -1
# print(notes[0]._ton)
# notes[4]._ton = -3
# print(notes[7])
#
# =============================================================================================================



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/V1fqV9pfARQ
# Подвиг 8 (на повторение). В программе объявлен базовый класс Function (функция) следующим образом:
# class Function:
#     def __init__(self):
#         self._amplitude = 1.0     # амплитуда функции
#         self._bias = 0.0          # смещение функции по оси Oy
#     def __call__(self, x, *args, **kwargs):
#         return self._amplitude * self._get_function(x) + self._bias
#     def _get_function(self, x):
#         raise NotImplementedError('метод _get_function должен быть переопределен в дочернем классе')
#     def __add__(self, other):
#         if type(other) not in (int, float):
#             raise TypeError('смещение должно быть числом')
#         obj = self.__class__(self)
#         obj._bias = self._bias + other
#         return obj
# Здесь в инициализаторе создаются два локальных атрибута:
# _amplitude - амплитуда функции;
# _bias - смещение функции по оси ординат (Oy).
# Далее, в методе __call__() берется значение функции в точке x через метод _get_function(), который должен быть определен
# в дочерних классах, умножается на амплитуду функции и добавляется ее смещение. Следующий метод __add__() позволяет менять смещение функции,
# изменяя атрибут _bias на указанное значение other.
# Обратите внимание, в методе __add__() происходит создание нового объекта командой:
# obj = self.__class__(self)
# Здесь __class__ - это ссылка на класс, к которому относится объект self. Благодаря этому в базовом классе можно создавать
# объекты соответствующих дочерних классов.В момент создания объекта ему передается параметр self как аргумент.
# Так будет создаваться копия объекта, т.е. новый объект с тем же набором и значениями локальных атрибутов.
# Чтобы обеспечить этот функционал, объявите дочерний класс с именем Linear (линейная функция y = k*x + b),
# объекты которого должны создаваться командами:
# obj = Linear(k, b)
# linear = Linear(obj)  # этот вариант используется в базовом классе в методе __add__()
# В первом случае происходит создание объекта линейной функции с параметрами k и b. Во втором - создание объекта со
# значениями параметров k и b, взятыми из объекта obj.
# В каждом объекте класса Linear должны создаваться локальные атрибуты с именами _k и _b с соответствующими значениями.
# В результате будет создан универсальный базовый класс Function для работы с произвольными функциями от одного аргумента.
# Применять эти классы можно следующим образом (эти строчки в программе писать не нужно):
# f = Linear(1, 0.5)
# f2 = f + 10   # изменение смещения (атрибут _bias)
# y1 = f(0)     # 0.5
# y2 = f2(0)    # 10.5
# Пропишите в базовом классе Function еще один магический метод для изменения масштаба (амплитуды) функции, чтобы был доступен оператор умножения:
# f = Linear(1, 0.5)
# f2 = f * 5    # изменение амплитуды (атрибут _amplitude)
# y1 = f(0)     # 0.5
# y2 = f2(0)    # 2.5
# P.S. В программе следует объявить только классы. На экран выводить ничего не нужно.



# class Function:
#     def __init__(self):
#         self._amplitude = 1.0     # амплитуда функции
#         self._bias = 0.0          # смещение функции по оси Oy
#
#     def __call__(self, x, *args, **kwargs):
#         return self._amplitude * self._get_function(x) + self._bias
#
#     def _get_function(self, x):
#         raise NotImplementedError('метод _get_function должен быть переопределен в дочернем классе')
#
#     def __add__(self, other):
#         if type(other) not in (int, float):
#             raise TypeError('смещение должно быть числом')
#
#         obj = self.__class__(self)
#         obj._bias = self._bias + other
#         return obj
#
#     # здесь добавляйте еще один магический метод для умножения
#     def __mul__(self, other):
#         if type(other) not in (int, float):
#             raise TypeError('смещение должно быть числом')
#
#         obj = self.__class__(self)
#         obj._amplitude *= other
#         return obj
#
# # здесь объявляйте класс Linear
#
# class Linear(Function):
#     def __init__(self, k=None, b=None):
#         super().__init__()
#         if isinstance(k, Linear):
#             self._k, self._b = k._k, k._b
#         else:
#             self._k = k
#             self._b = b
#
#     def _get_function(self, x):
#         return self._k * x + self._b
#
#
# f = Linear(1, 0.5)
# print(f._k)
# f2 = f + 10   # изменение смещения (атрибут _bias)
# y1 = f(0)     # 0.5
# y2 = f2(0)    # 10.5




# ================================================================================================


# Подвиг 9 (на повторение). В программе объявлен класс и создается его объект:
# class Shop:
#     ID_SHOP_ITEM = 0
# sp = Shop()
# sp.ID_SHOP_ITEM += 1
# print(Shop.ID_SHOP_ITEM)
# Выберите все верные утверждения, связанные с этой программой.

# (NO) - в строчке sp.ID_SHOP_ITEM += 1 возникнет ошибка, так как это эквивалентно команде sp.ID_SHOP_ITEM = sp.ID_SHOP_ITEM + 1, а локальный атрибут ID_SHOP_ITEM отсутствует в объекте sp
# (NO) - в строчке sp.ID_SHOP_ITEM += 1 атрибут ID_SHOP_ITEM класса Shop увеличивается на 1
# (YES) - на экране будет отображено значение 0
# (YES) - в строчке sp.ID_SHOP_ITEM += 1 создается новая локальная переменная ID_SHOP_ITEM со значением 1