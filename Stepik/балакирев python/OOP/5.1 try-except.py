# print('Я к вам пишу — чего же боле?')
# print('Что я могу еще сказать?')
# print('Теперь, я знаю, в вашей воле')
# print('Меня презреньем наказать.')
# print(a)    #NameError: name 'a' is not defined
# 1/ 0 #ZeroDivisionError: division by zero  исключение в процессе выполнения
#  1/0 #IndentationError: unexpected indent с пробелом - исключение в процессе компиляции(как правило синтаксические ошибки), программа вообще не выполняется
# print('Но вы, к моей несчастной доле')
# print('Хоть каплю жалости храня,')
# print('Вы не оставите меня.')
# также могут быть ошибки при работе с файлами, которые проконтролировать сложно
# try:
#     f = open('myfile.txt') #FileNotFoundError: [Errno 2] No such file or directory: 'myfile.txt'
# except FileNotFoundError:
#     print('file not found')

# try:
#     x, y = map(int, input().split())
#     res = x / y
#     print(res)
# except ValueError:
#     print('Value error')
# except ZeroDivisionError:
#     print('Zero division error')


# try:
#     x, y = map(int, input().split())
#     res = x / y
#     print(res)
# except (ValueError, ZeroDivisionError):
#     print('Value error')

# можно прописать не zerodivision error, a arithmetic error, но он будет отлавливать тогда все арифметические ошибки(а это не есть хорошо)


# try:
#     x, y = map(int, input().split())
#     res = x / y
#     print(res)
#
# except Exception: #так не делать!!!!!!!!!!! сначала
#     print('error')
# except ValueError:
#     print('Value error')



# ==================================================================================================



# Подвиг 1. Какие виды исключений бывают в языке Python?
#
# (YES) - исключения в процессе компиляции программы (синтаксические)
# (YES) - исключения в процессе выполнения программы (момента исполнения)
# (NO) - исключения в работе интерпретатора языка Python
# (NO) - исключения в работе интегрированной среды (например, PyCharm)


# =======================================================================================================



#
# Подвиг 2. Имеется следующий фрагмент программы:
#
# try:
#     val = float(input())
# except ValueError as e:
#     print(e)
#
# При каких входных данных выполнение программы перейдет в блок except?
#
# (NO) - при вводе не числовых или целочисленных значений
# (NO) - при вводе вещественных или целочисленных значений
# (NO) - при вводе не числовых или вещественных значений
# (YES) - при вводе любых не числовых значений


# =========================================================================================================



# Подвиг 3. В программе объявлена функция:
#
# def get_number(x):
#     try:
#         return int(x)
#     except:
#         try:
#             return float(x)
#         except:
#             return x
#
# И вызывается со следующими аргументами:
#
# res_1 = get_number('-5')
# res_2 = get_number('5.78')
# res_3 = get_number('8(912)000-000-00')
#
# Выберите все верные утверждения, связанные с этой программой.

# (NO) - при передаче функции get_number() вещественного значения она завершится с ошибкой, т.к. сначала нужно делать преобразование в вещественный тип (float), а затем - в целочисленный
# (YES) - при вызове функции get_number(True) она возвратит значение 1
# (YES) - res_1 равно числу -5; res_2 равно числу 5.78; res_3 равно строке '8(912)000-000-00'
# (YES) - при передаче функции get_number() аргумента, который может быть преобразован в целое или вещественное число, будет возвращено число, иначе возвращается переданное значение x без изменений
# (NO) - при вызове функции get_number(True) она возвратит значение True



# ==========================================================================================================





# Подвиг 4. Имеется следующая иерархия классов исключений:
# https://ucarecdn.com/5a24282a-6c83-4255-8efa-70d864f81d1e/
# И записан фрагмент программы:
#
# try:
#     x, y = map(float, input().split())
#     d = x / y
# except ArithmeticError:
#     print('ArithmeticError')
# except ZeroDivisionError:
#     print('ZeroDivisionError')
#
# В каких случаях выполнение программы перейдет в блок обработки исключения ZeroDivisionError?


# (NO) - если значение y будет равно нулю
# (NO) - всегда будет переходить при возникновении исключения типа ZeroDivisionError
# (NO) - если ввести хотя бы одно не числовое значение
# (YES) - ни в каких, так как класс ZeroDivisionError является дочерним по отношению к классу ArithmeticError
# (NO) - если значение x будет равно нулю


# =========================================================================================================



# Подвиг 5. В программе объявлен класс Point:
# class Point:
#     def __init__(self, x, y):
#         self._x = x
#         self._y = y
#
# И создается объект этого класса:
# pt = Point(1, 2)
# Далее, вам нужно обратиться к атрибуту z объекта pt и, если такой атрибут существует, то вывести его значение на экран.
# Иначе вывести строку (без кавычек):
# "Атрибут с именем z не существует"
# Реализовать проверку следует с помощью блоков try/except.#
# Подсказка: при обращении к несуществующему атрибуту генерируется исключение AttributeError.


# class Point:
#     def __init__(self, x, y):
#         self._x = x
#         self._y = y
#
#
# pt = Point(1, 2)
#
# try:
#     print(pt.z)
# except AttributeError:
#     print("Атрибут с именем z не существует")


# ===========================================================================================

# Подвиг 6. Имеется следующий фрагмент программы:
#
# try:
#     x, y = map(float, input().split())
#     d = x / y
# except ZeroDivisionError:
#     print('ZeroDivisionError')
# except:
#     print('except')
#
# В каких случаях выполнение программы перейдет во второй блок except?
#
#
# (YES) - при возникновении любых исключений, кроме исключения ZeroDivisionError
# (YES) - при вводе хотя бы одного не числового значения
# (NO) - ни в каких, программа не будет выполнена, т.к. записывать два блока except для одного блока try нельзя
# (NO) - никогда не перейдет, т.к. общий блок except следует записывать первым

# ========================================================================================================




# Подвиг 7. В программе вводятся в одну строчку через пробел некоторые данные, например:
# "1 -5.6 2 abc 0 False 22.5 hello world"
# Эти данные разбиваются по пробелу и представляются в виде списка строк:
# lst_in = input().split()
# Ваша задача посчитать сумму всех целочисленных значений, присутствующих в списке lst_in. Результат (сумму) вывести на экран.
# Подсказка: отбор только целочисленных значений можно выполнить с помощь функции filter() с последующим их преобразованием
# в целые числа с помощью функции map() и, затем, вычислением их суммы с помощью функции sum(). Для отбора
# целочисленных значений рекомендуется объявить вспомогательную функцию, которая бы возвращала True для строк,
# в которых присутствует целое число и False - для всех остальных строк.
# Sample Input:
# 8 11 abcd -7.5 2.0 -5
# Sample Output
# 14

# lst_in = input().split()
# # lst_in = "1 -5.6 2 abc 0 False 22.5 hello world".split()
# def try_int(x):
#     try:
#         s = int(x)
#         return True
#     except:
#         return False
#
# lst_int = sum(list(map(int,(filter(lambda x: try_int(x), lst_in)))))
# print(lst_in)
# print(lst_int)



# =========================================================================================================




# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/zQDvmHlS6wg
# Подвиг 8. В программе вводятся в одну строчку через пробел некоторые данные, например:
# "1 -5.6 True abc 0 23.56 hello"
# Эти данные разбиваются по пробелу и представляются в виде списка строк:
# lst_in = input().split()
# Ваша задача сформировать новый список с именем lst_out, в котором строки с целыми числами будут представлены как целые числа
# (тип int), строки с вещественными числами, как вещественные (тип float), а остальные данные - без изменений.
# Например:
# lst_out = [1, -5.6, 'True', 'abc', 0, 23.56, 'hello']  # после обработки введенной строки "1 -5.6 True abc 0 23.56 hello"
# Реализовать эту задачу следует с помощью функции map() и объявления вспомогательной функции с механизмом обработки исключений
# для непосредственного преобразования данных в целые или вещественные числа.
# P.S. В программе нужно только сформировать список lst_out. На экран ничего выводить не нужно.
# Sample Input:
# hello 1 world -2 4.5 True
# Sample Output:


# lst_in = input().split()
# lst_in = 'hello 1 world -2 4.5 True'.split()
# def func(x):
#     try:
#         return int(x)
#     except:
#         try:
#             return float(x)
#         except:
#             return x
#
# lst_out = list(map(lambda x: func(x), lst_in))
# print(lst_out)



# ========================================================================================================




# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/eKxzgkKD1fI
# Подвиг 9. Объявите в программе класс Triangle, объекты которого создаются командой:
# tr = Triangle(a, b, c)
# где a, b, c - длины сторон треугольника (любые положительные числа). В каждом объекте класса Triangle должны формироваться
# локальные атрибуты _a, _b, _c с соответствующими значениями.
# Если в качестве хотя бы одной величины a, b, c передается не числовое значение, или меньше либо равно нулю, то должно
# генерироваться исключение командой:
# raise TypeError('стороны треугольника должны быть положительными числами')
# Если из переданных значений a, b, c нельзя составить треугольник (условие: каждая сторона должна быть меньше суммы двух других),
# то генерировать исключение командой:
# raise ValueError('из указанных длин сторон нельзя составить треугольник')
# Затем, на основе следующего набора данных:
# input_data = [(1.0, 4.54, 3), ('abc', 1, 2, 3), (-3, 3, 5.2), (4.2, 5.7, 8.7), (True, 3, 5), (7, 4, 6)]
# необходимо сформировать объекты класса Triangle, но только в том случае, если не возникло никаких исключений.
# Все созданные объекты представить в виде списка с именем lst_tr.
# P.S. В программе нужно только сформировать список lst_tr. На экран ничего выводить не нужно.


# class Triangle:
#     def __init__(self, a, b, c):
#         if type(a) not in (int, float) or type(b) not in (int, float) or type(c) not in (int, float):
#             raise TypeError('стороны треугольника должны быть положительными числами')
#         self._check_triangle(a, b, c)
#         self._a = a
#         self._b = b
#         self._c = c
#
#     @staticmethod
#     def _check_triangle(a, b, c):
#         if a > b + c or b > a + c or c > a + b:
#             raise ValueError('из указанных длин сторон нельзя составить треугольник')
#
#
# input_data = [(1.0, 4.54, 3), ('abc', 1, 2, 3), (-3, 3, 5.2), (4.2, 5.7, 8.7), (True, 3, 5), (7, 4, 6)]
# lst_tr = []
# for i in input_data:
#     try:
#         a = Triangle(*i)
#     except (TypeError, ValueError):
#         pass
#     else:
#         lst_tr.append(a)
# print(lst_tr)


# ===============================================================================================




# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/0vmRMf5f4Iw
# Подвиг 10. Объявите в программе класс FloatValidator, объекты которого создаются командой:
# fv = FloatValidator(min_value, max_value)
# где min_value, max_value - минимальное и максимальное допустимое значение (диапазон [min_value; max_value]).
# Объекты этого класса предполагается использовать следующим образом:
# fv(value)
# где value - проверяемое значение. Если value не вещественное число или не принадлежит диапазону [min_value; max_value], то генерируется исключение командой:
# raise ValueError('значение не прошло валидацию')
# По аналогии, объявите класс IntegerValidator, объекты которого создаются командой:
# iv = IntegerValidator(min_value, max_value)
# и используются командой:
# iv(value)
# Здесь также генерируется исключение:
# raise ValueError('значение не прошло валидацию')
# если value не целое число или не принадлежит диапазону [min_value; max_value].
# После этого объявите функцию с сигнатурой:
# def is_valid(lst, validators): ...
# где lst - список из данных; validators - список из объектов-валидаторов (объектов классов FloatValidator и IntegerValidator).
# Эта функция должна отбирать из списка все значения, которые прошли хотя бы по одному валидатору.
# И возвращать новый список с элементами, прошедшими проверку.
# Пример использования классов и функции (эти строчки в программе не писать):
# fv = FloatValidator(0, 10.5)
# iv = IntegerValidator(-10, 20)
# lst_out = is_valid([1, 4.5, -10.5, 100, True, 'abc', (1, 2)], validators=[fv, iv])   # [1, 4.5]
# P.S. В программе нужно только объявить классы и функцию. На экран ничего выводить не нужно.

class FloatValidator:
    __slots__ = 'min_value', 'max_value'
    def __init__(self, min_value, max_value):
        self.min_value = min_value
        self.max_value = max_value

    def __call__(self, value):
        if type(value) != float or value > self.max_value or value < self.min_value:
            raise ValueError('значение не прошло валидацию')
        return value

class IntegerValidator:
    __slots__ = 'min_value', 'max_value'
    def __init__(self, min_value, max_value):
        self.min_value = min_value
        self.max_value = max_value

    def __call__(self, value):
        if type(value) != int or value > self.max_value or value < self.min_value:
            raise ValueError('значение не прошло валидацию')
        return value


def is_valid(lst, validators):
    lst_out = []
    for data in lst:
        for validator in validators:
            try:
                s = validator(data)
            except ValueError:
                pass
            else:
                lst_out.append(s)
    return lst_out






fv = FloatValidator(0, 10.5)
iv = IntegerValidator(-10, 20)
lst_out = is_valid([1, 4.5, -10.5, 100, True, 'abc', (1, 2)], validators=[fv, iv])   # [1, 4.5]
print(lst_out)