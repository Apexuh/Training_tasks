# Даны две строки строчных латинских символов: строка J и строка S. Символы, входящие в строку J, — «драгоценности»,
# входящие в строку S — «камни». Нужно определить, какое количество символов из S одновременно являются «драгоценностями».
# Проще говоря, нужно проверить, какое количество символов из S входит в J.
#
# Это разминочная задача, к которой мы размещаем готовые решения. Она очень простая и нужна для того,
# чтобы вы могли познакомиться с нашей автоматической системой проверки решений. Ввод и вывод осуществляется через файлы,
# либо через стандартные потоки ввода-вывода, как вам удобнее.

# Ввод
# ab
#
# Вывод
# aabbccd
#
# import sys
#
# j = sys.stdin.readline().strip()
# s = sys.stdin.readline().strip()
#
# j = set(j)
# f = sum(s.count(i) for i in j)
#
# print(f)



# ========================================================================================





# Требуется найти в бинарном векторе самую длинную последовательность единиц и вывести её длину.
# Желательно получить решение, работающее за линейное время и при этом проходящее по входному массиву только один раз.
# Формат ввода
# Первая строка входного файла содержит одно число n, n ≤ 10000. Каждая из следующих n строк содержит ровно одно число —
# очередной элемент массива.
# Формат вывода
# Выходной файл должен содержать единственное число — длину самой длинной последовательности единиц во входном массиве.

# input:
# 5
# 1
# 0
# 1
# 0
# 1
#
# output:
# 1

# n = [1,1,1,0,1]

# n = [int(input()) for _ in range(int(input()))]
#
# k = max(map(lambda x: len(x),''.join(map(str, n)).split('0')))
# print(k)

# ====================================================================================


# Legend
# Дан упорядоченный по неубыванию массив целых 32-разрядных чисел. Требуется удалить из него все повторения.
# Желательно получить решение, которое не считывает входной файл целиком в память, т.е., использует лишь константный объем памяти в процессе работы.
# Input format
# Первая строка входного файла содержит единственное число n, n ≤ 1000000.
# На следующих n строк расположены числа — элементы массива, по одному на строку. Числа отсортированы по неубыванию.
# Output format
# Выходной файл должен содержать следующие в порядке возрастания уникальные элементы входного массива.
#
# input:
# 5
# 2
# 4
# 8
# 8
# 8
# output:
# 2
# 4
# 8

# inp = [2,4,8,8,8]
# # inp = [int(input()) for _ in range(int(input()))]
#
# # inp = sorted(set(inp))
# inp = (i for i in inp if )
#
# print(*inp, sep='\n')



# ========================================================
